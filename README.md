# tmx-rpc-framework
> 写这个项目的动机来自于我在实习过程中的一次性能调优. 
> 那个场景是, 我的代码需要循环的远程调用另一个基础组件后做相应的逻辑. 由于两端通信的
> 方式是基于 HTTP + JSON , 最终的结果是, 在循环次数过大的时候性能非常拖沓. 
> 实习结束后, 本着提升自己, 学习造轮子, 努力成为一名开源人的目的, 
> 我便萌生了自己写一个简易的 RPC 框架的想法. 虽说 RPC 的理论知识不难, 但在实现的过程中, 我也遇到了许多的问题. 
> 通过不断的尝试去解决这些问题, 我学会了不少 RPC 框架底层原理以及各种 Java 编码技巧.  

## 介绍
tmx-rpc-framework 是一个基于 Netty + Zookeeper + Protostuff 实现的 RPC 框架, 他支持优雅的使用注解的方式进行服务发现与注册. 
Netty 在框架中主要是提供 NIO 的通信方式, 此外, 双向心跳机制和对通信协议的封装也是基于 Netty 来实现的. 
Zookeeper 是作为框架的注册中心, 得益于 Zookeeper 的 Watcher 设计, 服务提供者(provider)在注册与注销服务时, 
订阅相应接口的服务消费者(consumer)都能得到及时的反馈. 


## To-do-list
- [x] 使用 Netty（基于 NIO）作为底层网络通信
- [x] 使用 Kryo 作为序列化框架
- [x] 使用 Zookeeper 作为注册中心, 管理服务提供者的地址信息
- [x] 使用 Map 缓存已经建立的 Channel 避免重复连接服务端
- [x] 使用 CompletableFuture 异步接收RPC执行结果
- [x] 增加 Netty 双向心跳机制
- [x] 使用注解进行服务注册(提供者)和服务消费(消费者)
- [x] 适配 Spring
- [x] 集成 Spring Boot
- [x] 支持读取配置文件(rpc.properties)配置文件来配置
- [x] 支持简易的 SPI
- [x] 序列化方式可配置
- [x] 客户端选择服务提供者的时候进行负载均衡 (发布服务的时候增加 一个 loadbalance 参数)
- [x] 增加服务版本号 (version, group)
- [x] 自己写一个网络通信协议, 原有的 RpcRequest 和 RpcRequest 对象作为消息体
  - 魔数: 4 个字节, 用来服务端筛选有效报文
  - 序列化框架编号: 与客户端商量好序列化方式
  - 消息体长度
- [ ] ......  